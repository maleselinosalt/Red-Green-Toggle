//*****************************************************************************
// Copyright (c) 2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the  
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file was automatically generated by the Tiva C Series PinMux Utility
// Version: 1.0.4
//
//*****************************************************************************

#include <stdint.h>
#include <stdbool.h>
#include "RG_Toggle.h"
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "inc/hw_gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/pin_map.h"
#include "driverlib/gpio.h"
#include "C:\ti\TivaWare_C_Series-2.1.4.178\inc\tm4c123gh6pm.h"
#include "C:\ti\TivaWare_C_Series-2.1.4.178\driverlib\sysctl.h"

#define SW1	     		GPIO_PIN_4		// PF4
#define SW2      		GPIO_PIN_0		// PF0
#define red_LED     GPIO_PIN_1		// 0x02
#define blue_LED    GPIO_PIN_2		// 0x04
#define green_LED		GPIO_PIN_3		// 0x08

//*****************************************************************************
void
PortFunctionInit(void)
{
    //
    // Enable Peripheral Clocks 
    //
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

    //
    //First open the lock and select the bits we want to modify in the GPIO commit register.
    //
    HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
    HWREG(GPIO_PORTF_BASE + GPIO_O_CR) = 0x1;

    //
    //Now modify the configuration of the pins that we unlocked.
    //
	
    //
    // Enable pin PF0 for GPIOInput
    //
    GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, SW2);

    //
    // Enable pin PF3 for GPIOOutput
    //
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, green_LED);

    //
    // Enable pin PF4 for GPIOInput
    //
    GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, SW1);

    //
    // Enable pin PF1 for GPIOOutput
    //
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, red_LED);

    //
    // Enable pin PF2 for GPIOOutput
    //
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, blue_LED);


// ****** Initialized by PinMux Utility *************** 
	
    // enable pullup resistors using bitwise OR of PF4(0x10), PF0(0x01)
    GPIO_PORTF_PUR_R |= 0x11;        

}


void DelayInSec(double delay_in_s)
{
    // SysCtlClockGet() returns the PIOSC clock frequency of the Tiva (16 MHz +/- 1%)
    // 1 clock cycle (in seconds) = 1 / SysCtlClockGet() second
    // 1 loop of SysCtlDelay = 3 clock cycles = 3 / SysCtlClockGet() 
    // 1 second = SysCtlClockGet()  / 3
    SysCtlDelay(delay_in_s * (SysCtlClockGet()  / 3));
}
	

int main(void)
{
    uint8_t LED_data;
	
    // initializes the GPIO ports	
    PortFunctionInit();
		signed char c=0;
	
	
    while(1)
		{
			if (GPIOPinRead(GPIO_PORTF_BASE, SW2)==0x00) //SW2 is pressed, all off
				{
					
					LED_data^=blue_LED;	
					LED_data^=red_LED;
					LED_data^=green_LED;
					GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, LED_data);	//blue LED on
					GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00); // green LED off
					GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);	// red LED off
					c++; //c = 1
					SysCtlDelay(2666667);	// about 0.5 second delay
					
					GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	//blue LED on
					GPIOPinWrite(GPIO_PORTF_BASE, green_LED, LED_data); // green LED off
					GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);	// red LED off
					c++; //c = 2
					SysCtlDelay(2666667);	// about 0.5 second delay
					
					GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	//blue LED on
					GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00); // green LED off
					GPIOPinWrite(GPIO_PORTF_BASE, red_LED, LED_data);	// red LED off
					c++; //c = 3
					SysCtlDelay(2666667);	// about 0.5 second delay
					
					GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, LED_data);	//blue LED on
					GPIOPinWrite(GPIO_PORTF_BASE, green_LED, LED_data); // green LED off
					GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);	// red LED off
					c++; //c = 4
					SysCtlDelay(2666667);	// about 0.5 second delay
					
					GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, LED_data);	//blue LED on
					GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00); // green LED off
					GPIOPinWrite(GPIO_PORTF_BASE, red_LED, LED_data);	// red LED off
					c++; //c = 5
					SysCtlDelay(2666667);	// about 0.5 second delay
					
					GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	//blue LED on
					GPIOPinWrite(GPIO_PORTF_BASE, green_LED, LED_data); // green LED off
					GPIOPinWrite(GPIO_PORTF_BASE, red_LED, LED_data);	// red LED off
					c++; //c = 6
					SysCtlDelay(2666667);	// about 0.5 second delay
					
					GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, LED_data);	//blue LED on
					GPIOPinWrite(GPIO_PORTF_BASE, green_LED, LED_data); // green LED off
					GPIOPinWrite(GPIO_PORTF_BASE, red_LED, LED_data);	// red LED off
					c++;//c = 7
					SysCtlDelay(2666667);	// about 0.5 second delay
					c-=7;

				}
				
			else
				{
					if(GPIOPinRead(GPIO_PORTF_BASE, SW1)==0x00) //SW1 is pressed 
						{
							switch(c)
							{
								LED_data^=blue_LED;	
								LED_data^=red_LED;
								LED_data^=green_LED;
								
								case 1:
									GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, LED_data);	//blue LED on
									GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00); // green LED off
									GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);	// red LED off
									DelayInSec(0.5);
								
								case 2:
									GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	//blue LED off
									GPIOPinWrite(GPIO_PORTF_BASE, green_LED, LED_data); // green LED on
									GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);	// red LED off
									DelayInSec(0.5);
								
								case 3:
									GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	//blue LED off
									GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00); // green LED off
									GPIOPinWrite(GPIO_PORTF_BASE, red_LED, LED_data);	// red LED on
									DelayInSec(0.5);
								
								case 4:
									GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, LED_data);	//blue LED on
									GPIOPinWrite(GPIO_PORTF_BASE, green_LED, LED_data); // green LED on
									GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);	// red LED off
									DelayInSec(0.5);
								
								case 5:
									GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, LED_data);	//blue LED on
									GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00); // green LED off
									GPIOPinWrite(GPIO_PORTF_BASE, red_LED, LED_data);	// red LED on
									DelayInSec(0.5);
								
								case 6:
									GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	//blue LED off
									GPIOPinWrite(GPIO_PORTF_BASE, green_LED, LED_data); // green LED on
									GPIOPinWrite(GPIO_PORTF_BASE, red_LED, LED_data);	// red LED on
									DelayInSec(0.5);
								
								case 7:
									GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, LED_data);	//blue LED on
									GPIOPinWrite(GPIO_PORTF_BASE, green_LED, LED_data); // green LED on
									GPIOPinWrite(GPIO_PORTF_BASE, red_LED, LED_data);	// red LED on
									DelayInSec(0.5);
									
							}
						}
					else //SW1 is not pressed, toggle red LED (PF3)
						{
							GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	// green LED off
							GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	// green LED off

							DelayInSec(0.5);   // about 0.5 second delay
							LED_data^=red_LED; // bitwise XOR red LED (PF1)
							GPIOPinWrite(GPIO_PORTF_BASE, red_LED, LED_data); // red LED on
						}
				}		
					
    }
}

